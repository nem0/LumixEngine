include "pipelines/common.glsl"
vertex_shader [[
	
	layout (location = 0) out vec2 v_uv;
	
	void main()
	{
		gl_Position = fullscreenQuad(gl_VertexID, v_uv);
	}
]]

fragment_shader [[
    layout (location = 0) in vec2 v_uv;
	layout (location = 0) out vec4 o_color;

	layout (binding=0) uniform sampler2D u_depth_buffer;
	layout (binding=1) uniform sampler2D u_normal_buffer;
	layout(std140, binding = 4) uniform Drawcall {
		float u_radius;
		float u_intensity;
	};
    
    const int samples = 16;
    const float negInvRadSqr = -1.0/u_radius*u_radius;

	vec3 getViewNormal(vec2 tex_coord)
	{
		vec3 wnormal = texture(u_normal_buffer, tex_coord).xyz * 2 - 1;
		vec4 vnormal = Global.view * vec4(wnormal, 0);
		return vnormal.xyz;
    }

    float GetAO(vec2 tex_coord, vec3 p, vec3 n)
    {
        // ao calculation based on: https://frictionalgames.com/2014-01-tech-feature-ssao-and-temporal-blur/
        // and: https://www.gamedev.net/articles/programming/graphics/a-simple-and-practical-approach-to-ssao-r2753/

        vec3 diff = getViewPosition(u_depth_buffer, Global.inv_projection, tex_coord) - p;

        float distSqr = dot(diff, diff);
        float invLength = inversesqrt(distSqr);
        float falloff = saturate(1.0 + distSqr * negInvRadSqr);
        float angle = dot(n, diff) * invLength;

        return max(angle, 0.0)*falloff;
    }
	
	void main()
	{
		vec3 p = getViewPosition(u_depth_buffer, Global.inv_projection, v_uv);
		vec3 n = getViewNormal(v_uv);

        float rad = saturate(u_radius/-p.z);
        float ao = 0.0;
        for (lowp int i=0; i<samples; i++)
        {
            vec2 coord = POISSON_DISK_16[i]*rad;
            vec2 sampleUv = v_uv + coord;
            if( ( sampleUv.x < 0.0 ) || ( sampleUv.x > 1.0 ) || ( sampleUv.y < 0.0 ) || ( sampleUv.y > 1.0 ) )
                continue;
            ao += GetAO(v_uv + coord*0.25, p, n)*0.25;
            ao += GetAO(v_uv + coord*0.50, p, n)*0.25;
            ao += GetAO(v_uv + coord*0.75, p, n)*0.25;
            ao += GetAO(sampleUv, p, n)*0.25;
            
        }

        ao /= samples;
        ao = saturate(ao * u_intensity);
        ao = 1.0 - ao;

        o_color = vec4(ao, 0, 0, 1);
	}
]]