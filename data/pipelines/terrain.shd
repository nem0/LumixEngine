include "pipelines/common.glsl"

texture_slot {
	name = "Heightmap",
	uniform = "u_hm",
	default_texture = "textures/common/white.tga"
}

texture_slot {
	name = "Albedo",
	uniform = "u_albedo",
	default_texture = "textures/common/white.tga"
}

texture_slot {
	name = "Splatmap",
	uniform = "u_splatmap",
	default_texture = "textures/common/white.tga"
}

vertex_shader [[
	#ifdef EDGE
		out int vertex_id;
	#else
		out vec2 v_step;
		out vec3 v_pos;
		out vec2 v_lod_uv;
	#endif
	uniform int u_lod;
	uniform ivec4 u_from_to;
	uniform vec4 u_uv_from_to;
	uniform vec3 u_rel_camera_pos;
	
	void main()
	{
		#ifdef EDGE
			vertex_id = gl_VertexID;
		#else 
			int w = u_from_to.z - u_from_to.x;
			int h = u_from_to.w - u_from_to.y;
			ivec2 ij = ivec2(
				u_from_to.x + gl_VertexID % w,
				u_from_to.y + gl_VertexID / w
			);
		
			v_step.x = 1 / float(w);
			v_step.y = 1 / float(h);
			v_pos = vec3(ij.x, 0.0, ij.y) * (1 << u_lod);
		
			v_lod_uv.x = (gl_VertexID % w) * v_step.x;
			v_lod_uv.y = (gl_VertexID / w) * v_step.y;
			
			v_lod_uv = u_uv_from_to.xy + (u_uv_from_to.zw -  u_uv_from_to.xy) * v_lod_uv;
			
			v_step *= u_uv_from_to.zw - u_uv_from_to.xy;
		#endif
	}
]]


geometry_shader [[
	layout (points) in;
	#ifdef EDGE
		layout (triangle_strip, max_vertices = 20) out;
		in int vertex_id[];
	#else 
		layout (triangle_strip, max_vertices = 4) out;
		in vec2 v_step[];
		in vec3 v_pos[];
		in vec2 v_lod_uv[];
	#endif
	
	out vec2 v_uv;
	out vec2 v_uv_sub;
	uniform vec3 u_position;
	uniform int u_lod;
	layout(binding = 0) uniform sampler2D u_hm;
	uniform vec3 u_rel_camera_pos;

	const float hscale = 128;

	#ifdef EDGE
		void emitStrip(vec3 pos, int vid, float sx, float sy, float uv_y, float uv_y_off)
		{
			if(pos.x >= -0.5 && pos.z >= -0.5 && pos.x + sx < 2048.5 && pos.z + sy < 2048.5) {
				vec3 v = pos + vec3(0, 0, sy * 0.5);
				v_uv = v.xz;
				v_uv_sub = vec2(vertex_id[0] / 64.0, uv_y + uv_y_off);
				float h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();

				v = pos;
				v_uv = v.xz;
				v_uv_sub = vec2(vertex_id[0] / 64.0, uv_y);
				h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();

				v = pos + vec3(sx * 0.5, 0, sy * 0.5);
				v_uv = v.xz;
				v_uv_sub = vec2(vertex_id[0] / 64.0 + 1 / 128.0, uv_y + uv_y_off);
				h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();

				v = pos + vec3(sx, 0, 0);
				v_uv = v.xz;
				v_uv_sub = vec2(vertex_id[0] / 64.0 + 2 / 128.0, uv_y);
				h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();

				if(vid < 63) {
					v = pos + vec3(sx, 0, sy * 0.5);
					v_uv = v.xz;
					v_uv_sub = vec2(vertex_id[0] / 64.0 + 2 / 128.0, uv_y + uv_y_off);
					h = texture(u_hm, v.xz / 2048).x * hscale;
					gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
					EmitVertex();
				}
				EndPrimitive();
			}
		}
		
		void emitStripV(vec3 pos, int vid, float sx, float sy, float uv_x, float uv_x_off)
		{
			if(pos.x >= -0.5 && pos.z >= -0.5 && pos.x + sx * 0.5 < 2048.5 && pos.z + sy < 2048.5) {
				vec3 v = pos + vec3(sx * 0.5, 0, 0);
				v_uv = v.xz;
				v_uv_sub = vec2(uv_x + uv_x_off, vertex_id[0] / 64.0);
				float h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();

				v = pos;
				v_uv = v.xz;
				v_uv_sub = vec2(uv_x, vertex_id[0] / 64.0);
				h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();

				v = pos + vec3(sx * 0.5, 0, sy * 0.5);
				v_uv = v.xz;
				v_uv_sub = vec2(uv_x + uv_x_off, vertex_id[0] / 64.0 + 1 / 128.0);
				h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();

				v = pos + vec3(0, 0, sy);
				v_uv = v.xz;
				v_uv_sub = vec2(uv_x, vertex_id[0] / 64.0 + 2 / 128.0);
				h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();
				
				if(vid < 63) {
					v = pos + vec3(sx * 0.5, 0, sy);
					v_uv = v.xz;
					v_uv_sub = vec2(uv_x + uv_x_off, vertex_id[0] / 64.0 + 2 / 128.0);
					h = texture(u_hm, v.xz / 2048).x * hscale;
					gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
					EmitVertex();
				}
				EndPrimitive();
			}
		}
	#endif
	
	void main()
	{
		float s = pow(2, u_lod);

		#ifdef EDGE
			ivec2 ij = ivec2(ivec2(u_rel_camera_pos.xz / s / 2) * s * 2) - ivec2(64 * s, 64 * s);
			vec3 pos = vec3(int(vertex_id[0] * s * 2 + ij.x), 0.0, ij.y);
			s = s * 2;

			emitStrip(pos, vertex_id[0], s, s, 0, 1 / 128.0);
			emitStrip(pos + vec3(0, 0, s * 64), vertex_id[0], s, -s, 1, -1/128.0);
			
			ij = ivec2(ivec2(u_rel_camera_pos.xz / s) * s) - ivec2(32 * s, 32 * s);
			pos = vec3(ij.x, 0.0, int(vertex_id[0] * s + ij.y));

			emitStripV(pos, vertex_id[0], s, s, 0, 1 / 128.0);
			emitStripV(pos + vec3(s * 64, 0, 0), vertex_id[0], -s, s, 1, -1/128.0);
						
		#else
			if(v_pos[0].x >= -0.5 && v_pos[0].z >= -0.5 && v_pos[0].x + s < 2048.5 && v_pos[0].z + s < 2048.5) {
				vec3 v = v_pos[0];
				v_uv = v.xz;
				v_uv_sub = v_lod_uv[0];
				float h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();

				v = v_pos[0] + vec3(s, 0, 0);
				v_uv = v.xz;
				v_uv_sub = v_lod_uv[0] + vec2(v_step[0].x, 0);
				h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();

				v = v_pos[0] + vec3(0, 0, s);
				v_uv = v.xz;
				v_uv_sub = v_lod_uv[0] + vec2(0, v_step[0].y);
				h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();

				v = v_pos[0] + vec3(s, 0, s);
				v_uv = v.xz;
				v_uv_sub = v_lod_uv[0] + vec2(v_step[0].x, v_step[0].y);
				h = texture(u_hm, v.xz / 2048).x * hscale;
				gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
				EmitVertex();
				EndPrimitive();
			}
		#endif
	}
]]


fragment_shader [[

	#ifdef DEFERRED
		layout(location = 0) out vec4 o_gbuffer0;
		layout(location = 1) out vec4 o_gbuffer1;
		layout(location = 2) out vec4 o_gbuffer2;
	#else
		layout(location = 0) out vec4 o_color;
	#endif

	in vec2 v_uv;
	in vec2 v_uv_sub;
	layout(binding = 0) uniform sampler2D u_hm;
	layout(binding = 1) uniform sampler2DArray u_slices;
	uniform int u_lod;
	
	void getData()
	{
		data.normal = vec3(0, 1, 0);
		data.albedo = pow(texture(u_slices, vec3(v_uv_sub, u_lod)), vec4(2.2));
		#ifdef ALPHA_CUTOUT
			if(data.albedo.a < 0.5) discard;
		#endif
		data.wpos = vec3(0);
		data.roughness = 1.0;
		data.metallic  = 0;
		data.emission = 0;
	}
	
	#ifdef DEPTH
		void main()
		{
		}
	#elif defined DEFERRED
		void main()
		{
			getData();
			o_gbuffer0 = vec4(data.albedo.rgb, data.roughness);
			o_gbuffer1 = vec4(data.normal, data.metallic);
			o_gbuffer2 = vec4(data.emission, 0, 0, 1);
		}

	#else 
		void main()
		{
			getData();
			
			o_color.rgb = vec3(1, 0, 1);
				
			o_color.w = 1;
		}
	#endif
]]