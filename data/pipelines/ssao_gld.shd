include "pipelines/common.glsl"

vertex_shader [[
	
	layout (location = 0) out vec2 v_uv;
	
	void main()
	{
		gl_Position = fullscreenQuad(gl_VertexID, v_uv);
	}
]]

fragment_shader [[
    layout (location = 0) in vec2 v_uv;
	layout (location = 0) out vec4 o_color;
	layout (binding=0) uniform sampler2D u_depth_buffer;
	layout (binding=1) uniform sampler2D u_normal_buffer;
    layout (binding=2) uniform sampler2D u_noise;
	layout(std140, binding = 4) uniform Drawcall {
		float u_radius;
		float u_intensity;
        vec4 u_res;
	};
    
    const int samples = 4;
    const vec2 kernel[4] = vec2[](
      vec2(-1, 0 ),
      vec2( 0,-1 ),
      vec2( 1, 0 ),
      vec2( 0, 1 )
    );

	vec3 getViewNormal(vec2 tex_coord)
	{
		vec3 wnormal = texture(u_normal_buffer, tex_coord).xyz * 2 - 1;
		vec4 vnormal = Global.view * vec4(wnormal, 0);
		return vnormal.xyz;
    }

    float GetAO(vec2 tex_coord, vec3 p, vec3 n)
    {
        // ao calculation based on: https://frictionalgames.com/2014-01-tech-feature-ssao-and-temporal-blur/
        // and: https://www.gamedev.net/articles/programming/graphics/a-simple-and-practical-approach-to-ssao-r2753/

        vec3 diff = getViewPosition(u_depth_buffer, Global.inv_projection, tex_coord) - p;

        float distSqr = dot(diff, diff);
        float invLength = inversesqrt(distSqr);
        float falloff = 1.0/(1.0 + distSqr);
        float angle = dot(n, diff) * invLength;

        return clamp(angle * falloff, 0, 1);
    }


	
	void main()
	{
		vec3 p = getViewPosition(u_depth_buffer, Global.inv_projection, v_uv);
		vec3 n = getViewNormal(v_uv);
        vec2 r = texture(u_noise, u_res.xy * v_uv / u_res.zw).xy*2.0 - 1.0;

        float rad = saturate(u_radius/-p.z);
        float ao = 0.0;

        for (lowp int i=0; i<samples; i++)
        {
            vec2 coord1 = reflect(kernel[i], r)*rad;
            ao += GetAO(v_uv + coord1, p, n);
            // too slow to use.
            //ao += GetAO(v_uv + coord1*0.33, p, n)*0.34;
            //ao += GetAO(v_uv + coord1*0.66, p, n)*0.33;
            //ao += GetAO(v_uv + coord1, p, n)*0.33;
            
        }

        ao /= samples;
        ao = pow(1.0-saturate(ao), u_intensity);

        o_color.rgb = vec3(ao);
		o_color.w = 1;
	}
]]