include "pipelines/common.glsl"

compute_shader [[
    layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

    layout (r8, binding = 0) uniform writeonly image2D u_output;
	layout (binding=1) uniform sampler2D u_depth_buffer;
	layout (binding=2) uniform sampler2D u_normal_buffer;
    layout (binding=3) uniform sampler2D u_random_rotation;
	layout(std140, binding = 4) uniform Drawcall {
		float u_radius;
		float u_intensity;
	};
    
    const int samples = 4;

    const vec2 kernel[4] = vec2[](
            vec2( 1, 0), vec2(-1, 0),
            vec2( 0, 1), vec2( 0,-1)
        );

    const vec2 mainUV = vec2(gl_GlobalInvocationID.xy) / (Global.framebuffer_size / 2);
    const float negInvRadSqr = -1.0/u_radius*u_radius;

	vec3 getViewNormal(vec2 tex_coord)
	{
		vec3 wnormal = texture(u_normal_buffer, tex_coord).xyz * 2 - 1;
		vec4 vnormal = Global.view * vec4(wnormal, 0);
		return vnormal.xyz;
    }

    float GetAO(vec2 tex_coord, vec3 p, vec3 n)
    {
        // ao calculation based on: https://frictionalgames.com/2014-01-tech-feature-ssao-and-temporal-blur/
        // and: https://www.gamedev.net/articles/programming/graphics/a-simple-and-practical-approach-to-ssao-r2753/

        vec3 diff = getViewPosition(u_depth_buffer, Global.inv_projection, tex_coord) - p;

        float distSqr = dot(diff, diff);
        float invLength = inversesqrt(distSqr);
        float falloff = saturate(1.0 + distSqr * negInvRadSqr);
        float angle = dot(n, diff) * invLength;

        return max(angle, 0.0)*falloff;
    }
	
	void main()
	{
		vec3 p = getViewPosition(u_depth_buffer, Global.inv_projection, mainUV);
		vec3 n = getViewNormal(mainUV);
        vec2 r = texture(u_random_rotation, Global.framebuffer_size * mainUV / 4).xy * 2 - 1;

        float rad = saturate(u_radius/-p.z);
        float ao = 0.0;

        for (lowp int i=0; i<samples; i++)
        {
            vec2 coord = reflect(kernel[i], r)*rad;
            ao += GetAO(mainUV + coord*0.33, p, n)*0.33;
            ao += GetAO(mainUV + coord*0.66, p, n)*0.33;
            ao += GetAO(mainUV + coord, p, n)*0.34;
            
        }
        barrier();

        ao /= samples;
        ao = saturate(ao * u_intensity);
        ao = 1.0 - ao;

        imageStore(u_output, ivec2(gl_GlobalInvocationID.xy), vec4(ao, 0, 0, 0));
	}
]]