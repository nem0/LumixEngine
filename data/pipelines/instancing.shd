include "pipelines/common.glsl"

compute_shader [[
	struct Indirect {
		uint vertex_count;
		uint instance_count;
		uint first_index;
		uint base_vertex;
		uint base_instance;
	};
	
	struct OutputData {
		vec4 rot;
		vec4 pos_scale;
		vec4 lod_fade;
	};

	struct InputData {
		vec4 rot;
		vec4 pos_scale;
	};

	layout(local_size_x = 256, local_size_y = 1) in;

	layout(binding = 0, std430) readonly buffer InData {
		InputData b_input[];
	};

	layout(binding = 1, std430) coherent buffer OutData {
		uvec4 b_count;
		uvec4 b_offset;
		OutputData b_output[];
	};

	layout(binding = 2, std430) writeonly buffer OutData2 {
		Indirect b_indirect[];
	};

	layout(std140, binding = 4) uniform Drawcall {
		vec4 u_camera_offset;
		vec4 u_lod_distances;
		uvec4 u_lod_indices;
		uint u_total_count;
		uint u_instance_offset;
	};

	shared uvec4 group_count;

	uint getLOD(uint id) {
		vec3 p = b_input[id].pos_scale.xyz + u_camera_offset.xyz;
		float d = dot(p, p);
		if (d > u_lod_distances.z) return 3;
		else if (d > u_lod_distances.y) return 2;
		else if (d > u_lod_distances.x) return 1;
		return 0;
	}

	void main() {
		uint id = gl_GlobalInvocationID.y * gl_WorkGroupSize.x + gl_GlobalInvocationID.x;
		#ifdef PASS0
			if (id == 0) {
				b_offset = uvec4(0);
				b_count = uvec4(0);
			}
		#elif defined PASS1
			id += u_instance_offset;
			bool master = gl_LocalInvocationID.x == 0;
			if (master) {
				group_count = uvec4(0);
			}
			groupMemoryBarrier();
			barrier();

			if (id < u_total_count) {
				uint lod = getLOD(id);
				atomicAdd(group_count[lod], 1);
			}

			groupMemoryBarrier();
			barrier();

			if (master) {
				atomicAdd(b_count.x, group_count.x);
				atomicAdd(b_count.y, group_count.y);
				atomicAdd(b_count.z, group_count.z);
				atomicAdd(b_count.w, group_count.w);
				atomicAdd(b_offset.y, group_count.x);
				atomicAdd(b_offset.z, group_count.y + group_count.x);
				atomicAdd(b_offset.w, group_count.z + group_count.y + group_count.x);
			}
		#elif defined PASS2
			if (id <= u_lod_indices.x) {
				b_indirect[id].instance_count = b_count[0];
				b_indirect[id].base_instance = b_offset[0];
			}
			else if (id <= u_lod_indices.y) {
				b_indirect[id].instance_count = b_count[1];
				b_indirect[id].base_instance = b_offset[1];
			}
			else if (id <= u_lod_indices.z) {
				b_indirect[id].instance_count = b_count[2];
				b_indirect[id].base_instance = b_offset[2];
			}
			else if (id <= u_lod_indices.w) {
				b_indirect[id].instance_count = b_count[3];
				b_indirect[id].base_instance = b_offset[3];
			}
		#else
			id += u_instance_offset;
			if (id >= u_total_count) return;

			InputData inp = b_input[id];

			uint lod = getLOD(id);

			uint idx = atomicAdd(b_offset[lod], 1);

			b_output[idx].rot = inp.rot;
			b_output[idx].pos_scale = inp.pos_scale + vec4(u_camera_offset.xyz, 0);
			b_output[idx].lod_fade = vec4(0, 0, 0, 0);

		#endif
	}
]]